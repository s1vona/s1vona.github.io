<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Sivona">





<title>滴水逆向中级笔记 | Sivona&#39;s</title>



    <link rel="icon" href="/bug.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    




<meta name="generator" content="Hexo 4.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Sivona&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Sivona&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">滴水逆向中级笔记</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Sivona</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 10, 2021&nbsp;&nbsp;15:22:57</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/note/">note</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<p>本篇文章为个人学习笔记，可能不适合正常人看</p>
<p><del>持续更新中···</del> </p>
<p>基于滴水逆向中级班补充了部分64位的内容</p>
<p>很多数据结构源于win10 1511</p>
</blockquote>
<h1 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h1><h2 id="段寄存器结构"><a href="#段寄存器结构" class="headerlink" title="段寄存器结构"></a>段寄存器结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[0x1234],eax</span><br></pre></td></tr></table></figure>

<p>真正读写的地址是：ds.base + 0x1234</p>
<p>段寄存器共有8个：ES CS SS DS FS GS LDTR TR</p>
<p>段寄存器共有96位，可见部分有前16位</p>
<p>用结构体描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegMent</span>&#123;</span></span><br><span class="line">    WORD Seletor;</span><br><span class="line">    WORD Atrributes;<span class="comment">//属性，rwe</span></span><br><span class="line">    DWORD Base;<span class="comment">//段基址</span></span><br><span class="line">    DWORD Limit;<span class="comment">//段长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="段描述符与段选择子"><a href="#段描述符与段选择子" class="headerlink" title="段描述符与段选择子"></a>段描述符与段选择子</h2><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p><img src="https://bkimg.cdn.bcebos.com/pic/d6ca7bcb0a46f21fbe09bc4ba26d7c600c33874400db?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxNTA=,g_7,xp_5,yp_5/format,f_auto" alt=""></p>
<ul>
<li>P：P = 1 段描述符有效，反之无效，当我们通过指令将一个段描述符加载到段寄存器的时候，CPU第一件事情就是检查它的P位，若P无效则不会去做后续的其他检查</li>
<li>Atrributes：从第8字节Type到第23字节</li>
<li>Base：16-31 + 32-39 + 56-63</li>
<li>Limit：0-15 +  48-51 如果G位为1则单位为4K</li>
<li>S：S  = 1 代码段或者数据段描述符，S = 0 系统段描述符</li>
<li>Type：当S = 1时：11位标志代码还是数据，A是否已经被访问，W是否可写，E是否向上拓展，R是否可读，C是否是一致代码段<img src="https://img-blog.csdnimg.cn/20200924170933342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t3YW5zeQ==,size_16,color_FFFFFF,t_70#pic_center" alt=""></li>
<li>Type：当S = 0时：<img src="https://img-blog.csdnimg.cn/20200924182745540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0t3YW5zeQ==,size_16,color_FFFFFF,t_70#pic_center" alt=""></li>
<li>DB：影响CS段寻址，SS段ESP or SP，向下拓展的数据段的段上限4GB or 64KB</li>
</ul>
<p>查看gdt表与gdt表长度（字节为单位）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r gdtr</span><br><span class="line">gdtr&#x3D;fffff80082b0b000</span><br><span class="line">kd&gt; r gdtl</span><br><span class="line">gdtl&#x3D;006f</span><br><span class="line">kd&gt; dq fffff80082b0b000</span><br><span class="line">fffff800&#96;82b0b000  00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">fffff800&#96;82b0b010  00209b00&#96;00000000 00409300&#96;00000000</span><br><span class="line">fffff800&#96;82b0b020  00cffb00&#96;0000ffff 00cff300&#96;0000ffff</span><br><span class="line">fffff800&#96;82b0b030  0020fb00&#96;00000000 00000000&#96;00000000</span><br><span class="line">fffff800&#96;82b0b040  82008bb0&#96;c0700067 00000000&#96;fffff800</span><br><span class="line">fffff800&#96;82b0b050  5c40f321&#96;30003c00 00000000&#96;00000000</span><br><span class="line">fffff800&#96;82b0b060  00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">fffff800&#96;82b0b070  807c8e00&#96;00102500 00000000&#96;fffff800</span><br><span class="line">kd&gt; r idtr</span><br><span class="line">idtr&#x3D;fffff80082b0b070</span><br></pre></td></tr></table></figure>

<p>可以看到fffff800`82b0b070开始就是idt表的内容，在x64中gdt表的作用并没有那么多了，最多就是在进入内核态时将cs寄存器的权限改为0</p>
<h3 id="段选择子"><a href="#段选择子" class="headerlink" title="段选择子"></a>段选择子</h3><p><img src="https://img-blog.csdnimg.cn/20190608125634678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NzMzNzUx,size_16,color_FFFFFF,t_70" alt=""></p>
<ul>
<li>RPL：请求特权级别</li>
<li>TI：TI=0 查GDT表；TI=1 查LDT表（windows下不使用LDT）</li>
<li>Index：GDT表索引</li>
</ul>
<h3 id="奇怪的指令"><a href="#奇怪的指令" class="headerlink" title="奇怪的指令"></a>奇怪的指令</h3><p>除了mov指令，我们还可以使用LES、LSS、LDS、LFS、LGS修改寄存器</p>
<p>CS不能通过上述的指令进行修改，CS位代码段，CS的改变会导致EIP的改变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">6</span>];</span><br><span class="line">__asm&#123;</span><br><span class="line">    les eccx,fword ptr ds:[<span class="built_in">buffer</span>] <span class="comment">//高2字节给es，低4字节给ecx，好像这样比较隐蔽。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：RPL &lt;= DPL（在数值上）</p>
<h2 id="段权限检查"><a href="#段权限检查" class="headerlink" title="段权限检查"></a>段权限检查</h2><h3 id="CPL"><a href="#CPL" class="headerlink" title="CPL"></a>CPL</h3><p>CS、SS段选择子的后两位比较特殊称为：CPL（Current Privilege Level），标志当前CPU的特权等级</p>
<h3 id="DPL"><a href="#DPL" class="headerlink" title="DPL"></a>DPL</h3><p>DPL（Descriptor Privilege Level 描述符特权等级）：规定了访问该段所需要的特权级别是什么，如果你要访问我，你应具备什么样的特权。</p>
<p>比如：mov DS, AX ，如果AX指向的段DPL为0，那么当程序的CPL为3时这行指令是不会成功的。</p>
<h3 id="RPL"><a href="#RPL" class="headerlink" title="RPL"></a>RPL</h3><p>RPL（Request Privilege Level 请求特权级别）：RPL针对段选择子而言的，每个段的选择子都有自己的RPL</p>
<p>比如：mov ax,8 与 mov ax,b ，指向同一个段描述符，但RPL是不一样的</p>
<p>比如：当前程序处于0环，即CPL = 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,000b &#x2F;&#x2F;1011 RPL &#x3D; 3</span><br><span class="line">mov ds,ax &#x2F;&#x2F; ax 指向的段描述符的DPL &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>数据段（代码段和系统段并不相同）的权限检查：CPL &lt;= DPL 并且 RPL &lt;= DPL</p>
<p>为什么要有RPL？</p>
<ul>
<li>我们本可以用rw的权限去打开一个文件，但为了避免出错，有些时候我们使用只读的权限去打开。</li>
</ul>
<blockquote>
<p>思考SMEP、SMAP的实现</p>
</blockquote>
<h2 id="代码跨段跳转"><a href="#代码跨段跳转" class="headerlink" title="代码跨段跳转"></a>代码跨段跳转</h2><p>举例JMP 0x20:0x004183d7</p>
<p>流程如下：</p>
<ol>
<li>段选择子拆分，RPL = 00，TI = 0，Index = 4</li>
<li>查询GDT，因为TI = 0 所以查GDT表，Index = 4 找到对应的段描述符，四种情况可以跳转：代码段、调用门、TSS任务段、任务门（后三类都是系统段描述符）</li>
<li>权限检查，如果是非一致代码段，要求CPL == DPL 并且 RPL &lt;= DPL；如果是一致代码段，要求CPL &gt;= DPL</li>
<li>加载段描述符，通过以上检查后，CPU会将段描述符加载到CS段寄存器中</li>
<li>代码执行，CPU将CS.Base + Offset 的值写入EIP，然后执行CS:EIP处的代码，段间跳转结束</li>
</ol>
<ul>
<li>一致代码段：内核态和用户态共享的代码段，允许低特权访问高特权的代码</li>
<li>非一致代码段：只允许同级访问</li>
</ul>
<h2 id="长调用"><a href="#长调用" class="headerlink" title="长调用"></a>长调用</h2><p>JMP FAR 只能跳转到同级非一直代码段，但CALL FAR 可以通过调用门提权，提升CPL的权限。</p>
<h3 id="跨段不提权"><a href="#跨段不提权" class="headerlink" title="跨段不提权"></a>跨段不提权</h3><p>指令格式：CALL CS:EIP（EIP是废弃的，此处CS必须对应一个调用门段描述符）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push eip</span><br></pre></td></tr></table></figure>

<p>使用<code>RETF</code>返回</p>
<h3 id="跨段并提权"><a href="#跨段并提权" class="headerlink" title="跨段并提权"></a>跨段并提权</h3><p>指令格式：CALL CS:EIP（EIP是废弃的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;切换0环栈</span><br><span class="line">push SS</span><br><span class="line">push esp</span><br><span class="line">push cs</span><br><span class="line">push eip</span><br></pre></td></tr></table></figure>

<h2 id="调用门"><a href="#调用门" class="headerlink" title="调用门"></a>调用门</h2><blockquote>
<p>现代操作系统大都是分页的，所以这玩意估计也被时代抛弃了，但还是要简单记录一下（windows没有使用调用门！！  ）</p>
</blockquote>
<p><img src="http://i.imgur.com/Ai52bwJ.png" alt=""></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol>
<li>根据CS的值查GDT表，找到对应的段描述符，这个描述符是一个调用门</li>
<li>在调用门描述符中储存另一个代码段的段选择子</li>
<li>选择子指向的段的Base + 调用门中的段中偏移值 就是真正要执行的地址</li>
</ol>
<h3 id="翻墙理论"><a href="#翻墙理论" class="headerlink" title="翻墙理论"></a>翻墙理论</h3><p>去政府部门办事，进去的时候如果翻墙进去就会被KO，如果从大门进去把身份证件压在门卫那里就没问题；出来的时候不从大门出去而是翻墙出去一般是没人管你的XD</p>
<h2 id="中断门"><a href="#中断门" class="headerlink" title="中断门"></a>中断门</h2><ul>
<li>系统调用（现代CPU一般都支持快速系统调用而不是使用中断）</li>
<li>调试</li>
</ul>
<h3 id="查看IDT"><a href="#查看IDT" class="headerlink" title="查看IDT"></a>查看IDT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r idtr</span><br><span class="line">idtr&#x3D;fffff8007830b070</span><br><span class="line">kd&gt; r idtl</span><br><span class="line">idtl&#x3D;0fff</span><br><span class="line">kd&gt; dq fffff8007830b070</span><br><span class="line">fffff800&#96;7830b070  75fd8e00&#96;00104500 00000000&#96;fffff800</span><br><span class="line">fffff800&#96;7830b080  75fd8e00&#96;00104600 00000000&#96;fffff800</span><br><span class="line">fffff800&#96;7830b090  75fd8e03&#96;001047c0 00000000&#96;fffff800</span><br><span class="line">fffff800&#96;7830b0a0  75fdee00&#96;00104b40 00000000&#96;fffff800</span><br><span class="line">fffff800&#96;7830b0b0  75fdee00&#96;00104c40 00000000&#96;fffff800</span><br><span class="line">fffff800&#96;7830b0c0  75fd8e00&#96;00104d40 00000000&#96;fffff800</span><br><span class="line">fffff800&#96;7830b0d0  75fd8e00&#96;00104fc0 00000000&#96;fffff800</span><br><span class="line">fffff800&#96;7830b0e0  75fd8e00&#96;00105200 00000000&#96;fffff800</span><br></pre></td></tr></table></figure>

<h3 id="IDT表的构成"><a href="#IDT表的构成" class="headerlink" title="IDT表的构成"></a>IDT表的构成</h3><ul>
<li>任务门描述符</li>
<li>中断门描述符</li>
<li>陷阱门描述符</li>
</ul>
<p><img src="http://don7hao.github.io/img/gate_2.jpg" alt=""></p>
<blockquote>
<p>64位是16字节，最高4位保留，次4位为偏移高4位</p>
</blockquote>
<h2 id="陷阱门"><a href="#陷阱门" class="headerlink" title="陷阱门"></a>陷阱门</h2><h3 id="与中断门的区别"><a href="#与中断门的区别" class="headerlink" title="与中断门的区别"></a>与中断门的区别</h3><p>中断门执行时，会将IF位清零（存于EFLAGS中），但陷阱门不会。</p>
<p>如果IF为0意味着不再接受可屏蔽中断</p>
<ul>
<li><p>可屏蔽中断：触发中断时，CPU不再接受键盘等消息</p>
</li>
<li><p>系统断电时触发不可屏蔽中断，电源管理器不管IF位为多少都会触发中断，利用主板中的电容告知CPU完成清理工作</p>
</li>
</ul>
<h2 id="任务段"><a href="#任务段" class="headerlink" title="任务段"></a>任务段</h2><h3 id="任务状态段-Task-state-segment-TSS"><a href="#任务状态段-Task-state-segment-TSS" class="headerlink" title="任务状态段(Task-state segment, TSS)"></a><strong>任务状态段(Task-state segment, TSS)</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TSS</span> &#123;</span></span><br><span class="line">    DWORD link; <span class="comment">// 保存前一个 TSS 段选择子，使用 call 指令切换寄存器的时候由CPU填写。</span></span><br><span class="line">    <span class="comment">// 这 6 个值是固定不变的，用于提权，CPU 切换栈的时候用</span></span><br><span class="line">    DWORD esp0; <span class="comment">// 保存 0 环栈指针</span></span><br><span class="line">    DWORD ss0;  <span class="comment">// 保存 0 环栈段选择子</span></span><br><span class="line">    DWORD esp1; <span class="comment">// 保存 1 环栈指针</span></span><br><span class="line">    DWORD ss1;  <span class="comment">// 保存 1 环栈段选择子</span></span><br><span class="line">    DWORD esp2; <span class="comment">// 保存 2 环栈指针</span></span><br><span class="line">    DWORD ss2;  <span class="comment">// 保存 2 环栈段选择子</span></span><br><span class="line">    <span class="comment">// 下面这些都是用来做切换寄存器值用的，切换寄存器的时候由CPU自动填写。</span></span><br><span class="line">    DWORD cr3; </span><br><span class="line">    DWORD eip;  </span><br><span class="line">    DWORD eflags;</span><br><span class="line">    DWORD eax;</span><br><span class="line">    DWORD ecx;</span><br><span class="line">    DWORD edx;</span><br><span class="line">    DWORD ebx;</span><br><span class="line">    DWORD esp;</span><br><span class="line">    DWORD ebp;</span><br><span class="line">    DWORD esi;</span><br><span class="line">    DWORD edi;</span><br><span class="line">    DWORD es;</span><br><span class="line">    DWORD cs;</span><br><span class="line">    DWORD ss;</span><br><span class="line">    DWORD ds;</span><br><span class="line">    DWORD fs;</span><br><span class="line">    DWORD gs;</span><br><span class="line">    DWORD ldt;</span><br><span class="line">    DWORD io_map;<span class="comment">// 这个暂时忽略</span></span><br><span class="line">&#125; TSS;</span><br></pre></td></tr></table></figure>

<h3 id="TR寄存器"><a href="#TR寄存器" class="headerlink" title="TR寄存器"></a>TR寄存器</h3><p>系统启动时会将GDT中TSS段描述符的数据加载到TR寄存器中</p>
<ul>
<li><p>TR寄存器本质上是一个段寄存器</p>
</li>
<li><p>TR.Base指定TSS的基址</p>
</li>
<li><p>TR.Limit指定TSS的大小</p>
</li>
</ul>
<h2 id="任务门"><a href="#任务门" class="headerlink" title="任务门"></a>任务门</h2><p>虽然intel设计TSS旨用于多任务切换，但由于效率太低所以大多情况下只用于中断权限切换时更换esp和ss寄存器</p>
<p>任务门描述符：</p>
<p><img src="http://www.qfrost.com/images/WindowsKernel/Windows%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/Task_Gate_Descriptor.png" alt=""></p>
<h3 id="任务门执行过程"><a href="#任务门执行过程" class="headerlink" title="任务门执行过程"></a>任务门执行过程</h3><ol>
<li>INT N</li>
<li>查IDT表，找到中断门描述符</li>
<li>通过中断门描述符，找到TSS段选择子</li>
<li>查GDT表，找到任务段描述符并加载到TR寄存器中</li>
<li>使用TR寄存器指向的TSS段中的值修改相应寄存器</li>
<li>IRETD返回</li>
</ol>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table>
<thead>
<tr>
<th>Bit</th>
<th>Display when set</th>
<th>Display when clear</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>0x200</td>
<td>C</td>
<td>-</td>
<td>Copy on write.</td>
</tr>
<tr>
<td>0x100</td>
<td>G</td>
<td>-</td>
<td>Global.</td>
</tr>
<tr>
<td>0x80</td>
<td>L</td>
<td>-</td>
<td>Large page. This only occurs in PDEs, never in PTEs.</td>
</tr>
<tr>
<td>0x40</td>
<td>D</td>
<td>-</td>
<td>Dirty.</td>
</tr>
<tr>
<td>0x20</td>
<td>A</td>
<td>-</td>
<td>Accessed.</td>
</tr>
<tr>
<td>0x10</td>
<td>N</td>
<td>-</td>
<td>Cache disabled.</td>
</tr>
<tr>
<td>0x8</td>
<td>T</td>
<td>-</td>
<td>Write-through.</td>
</tr>
<tr>
<td>0x4</td>
<td>U</td>
<td>K</td>
<td>Owner (user mode or kernel mode).</td>
</tr>
<tr>
<td>0x2</td>
<td>W</td>
<td>R</td>
<td>Writeable or read-only. Only on multiprocessor computers and any computer running Windows Vista or later.</td>
</tr>
<tr>
<td>0x1</td>
<td>V</td>
<td></td>
<td>Valid.</td>
</tr>
<tr>
<td></td>
<td>E</td>
<td>-</td>
<td>Executable page. For platforms that do not support a hardware execute/noexecute bit, including many x86 systems, the E is always displayed.</td>
</tr>
</tbody></table>
<h3 id="虚拟地址转物理地址"><a href="#虚拟地址转物理地址" class="headerlink" title="虚拟地址转物理地址"></a>虚拟地址转物理地址</h3><p>以 9-9-9-9-12 分页举例：</p>
<p>先将要转化的地址比如fffff803a8f0a000后48位转化为二进制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">11111000 00000011 10101000 11110000 10100000 00000000 以9-9-9-9-12进行分割</span><br><span class="line">111110000 1f0</span><br><span class="line">000001110 0e</span><br><span class="line">101000111 147</span><br><span class="line">100001010 10a</span><br><span class="line">000000000000 0</span><br></pre></td></tr></table></figure>

<p>在cr3中取出顶级页表物理基址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r cr3</span><br><span class="line">cr3&#x3D;00000000238c1000</span><br></pre></td></tr></table></figure>

<p>找各级页表的索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !dq 00000000238c1000 + 1f0 * 8</span><br><span class="line">#238c1f80 00000000&#96;00784063 00000000&#96;00000000</span><br><span class="line">#238c1f90 00000000&#96;31d14863 00000000&#96;00000000</span><br><span class="line">#238c1fa0 00000000&#96;00000000 00000000&#96;3fedf863</span><br><span class="line">#238c1fb0 80000000&#96;00203863 80000000&#96;00203863</span><br><span class="line">#238c1fc0 80000000&#96;00203863 80000000&#96;00203863</span><br><span class="line">#238c1fd0 00000000&#96;3fedd863 00000000&#96;3fedb863</span><br><span class="line">#238c1fe0 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#238c1ff0 00000000&#96;00000000 00000000&#96;007a4063</span><br><span class="line"></span><br><span class="line">kd&gt; !dq 00000000&#96;00784000 + e * 8</span><br><span class="line">#  784070 00000000&#96;00785063 00000000&#96;00000000</span><br><span class="line">#  784080 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  784090 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  7840a0 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  7840b0 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  7840c0 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  7840d0 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  7840e0 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line"></span><br><span class="line">kd&gt; !dq 00000000&#96;00785000 + 147 * 8</span><br><span class="line">#  785a38 00000000&#96;007a2063 00000000&#96;00000000</span><br><span class="line">#  785a48 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  785a58 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  785a68 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  785a78 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  785a88 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  785a98 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">#  785aa8 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line"></span><br><span class="line">kd&gt; !dq 00000000&#96;007a2000 + 10a * 8</span><br><span class="line">#  7a2850 00000000&#96;0930a963 00000000&#96;0930b963</span><br><span class="line">#  7a2860 00000000&#96;00000000 80000000&#96;0930d963</span><br><span class="line">#  7a2870 80000000&#96;0930e963 80000000&#96;0930f963</span><br><span class="line">#  7a2880 80000000&#96;09310963 80000000&#96;09311963</span><br><span class="line">#  7a2890 80000000&#96;09312963 80000000&#96;09313963</span><br><span class="line">#  7a28a0 00000000&#96;00000000 80000000&#96;09315963</span><br><span class="line">#  7a28b0 80000000&#96;09316963 80000000&#96;09317963</span><br><span class="line">#  7a28c0 80000000&#96;09318963 80000000&#96;09319963</span><br></pre></td></tr></table></figure>

<p>验证一下是否转化成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !dq 00000000&#96;0930a000</span><br><span class="line"># 930a000 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line"># 930a010 00209b00&#96;00000000 00409300&#96;00000000</span><br><span class="line"># 930a020 00cffb00&#96;0000ffff 00cff300&#96;0000ffff</span><br><span class="line"># 930a030 0020fb00&#96;00000000 00000000&#96;00000000</span><br><span class="line"># 930a040 a8008bf0&#96;b0700067 00000000&#96;fffff803</span><br><span class="line"># 930a050 3540f3bc&#96;30003c00 00000000&#96;00000000</span><br><span class="line"># 930a060 00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line"># 930a070 a6bd8e00&#96;00108500 00000000&#96;fffff803</span><br><span class="line"></span><br><span class="line">kd&gt; dq fffff803a8f0a000</span><br><span class="line">fffff803&#96;a8f0a000  00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">fffff803&#96;a8f0a010  00209b00&#96;00000000 00409300&#96;00000000</span><br><span class="line">fffff803&#96;a8f0a020  00cffb00&#96;0000ffff 00cff300&#96;0000ffff</span><br><span class="line">fffff803&#96;a8f0a030  0020fb00&#96;00000000 00000000&#96;00000000</span><br><span class="line">fffff803&#96;a8f0a040  a8008bf0&#96;b0700067 00000000&#96;fffff803</span><br><span class="line">fffff803&#96;a8f0a050  3540f3bc&#96;30003c00 00000000&#96;00000000</span><br><span class="line">fffff803&#96;a8f0a060  00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">fffff803&#96;a8f0a070  a6bd8e00&#96;00108500 00000000&#96;fffff803</span><br></pre></td></tr></table></figure>





<h3 id="页表虚拟地址计算"><a href="#页表虚拟地址计算" class="headerlink" title="页表虚拟地址计算"></a>页表虚拟地址计算</h3><p>想要改写页表或者查看页表肯定要知道页表的虚拟地址</p>
<p>在xp中pte虚拟基址固定为：0xc0000000</p>
<p>在win10中pte虚拟基址储存在nt中是随机的，在windbg中查看如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pte 0</span><br><span class="line">                                           VA 0000000000000000</span><br><span class="line">PXE at FFFFF6FB7DBED000    PPE at FFFFF6FB7DA00000    PDE at FFFFF6FB40000000    PTE at FFFFF68000000000</span><br><span class="line">contains 0470000039122867  contains 0000000000000000</span><br><span class="line">pfn 39122     ---DA--UWEV  contains 0000000000000000</span><br><span class="line">not valid</span><br></pre></td></tr></table></figure>

<p>举个例子，计算gdt表所在页的pte虚拟地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; r gdtr</span><br><span class="line">gdtr&#x3D;fffff803a8f0a000</span><br></pre></td></tr></table></figure>

<p>取后48位有效位，因为每页4k所以左移12位，然后因为pte中每项为8字节所以左移3位，最后加上pte虚拟基址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f803a8f0a000 &gt;&gt; 12 &lt;&lt; 3 &#x3D; 7C01D47850</span><br><span class="line">7C01D47850 + FFFFF68000000000 &#x3D; FFFFF6FC01D47850</span><br></pre></td></tr></table></figure>

<p>在windbg中验证一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !pte fffff803a8f0a000</span><br><span class="line">                                           VA fffff803a8f0a000</span><br><span class="line">PXE at FFFFF6FB7DBEDF80    PPE at FFFFF6FB7DBF0070    PDE at FFFFF6FB7E00EA38    PTE at FFFFF6FC01D47850</span><br><span class="line">contains 0000000000784063  contains 0000000000785063  contains 00000000007A2063  contains 000000000930A963</span><br><span class="line">pfn 784       ---DA--KWEV  pfn 785       ---DA--KWEV  pfn 7a2       ---DA--KWEV  pfn 930a      -G-DA--KWEV</span><br></pre></td></tr></table></figure>

<p>pde的虚拟地址是pte表虚拟地址的pte，即对pte的虚拟地址做以上运算，同理pxe和ppe</p>
<h2 id="TLB-Translation-Lookaside-Buffer"><a href="#TLB-Translation-Lookaside-Buffer" class="headerlink" title="TLB(Translation Lookaside Buffer)"></a>TLB(Translation Lookaside Buffer)</h2><table>
<thead>
<tr>
<th>LA（线性地址）</th>
<th>PA（物理地址）</th>
<th>ATTR（属性）</th>
<th>LRU（统计）</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>属性为各级页表and的结果</li>
<li>统计记录该页是否常用</li>
<li>不同的CPU表的大小不一样</li>
<li>只要cr3改变，TLB立即刷新，一个CPU核心一个TLB</li>
<li>页表G位与TLB是否刷新有关</li>
<li>INVLPG指令可删除某些映射关系</li>
</ul>
<h3 id="TLB种类"><a href="#TLB种类" class="headerlink" title="TLB种类"></a>TLB种类</h3><p>根据页表的种类分为以下4组TLB：</p>
<ul>
<li>第一组：缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）</li>
<li>第二组：缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）</li>
<li>第三组：缓存大尺寸页表（2M/4M字节页面）的指令页表缓存（Instruction-TLB）</li>
<li>第四组：缓存大尺寸页表（2M/4M字节页面）的数据页表缓存（Data-TLB）</li>
</ul>
<blockquote>
<p>利用1、2组表缓存不同步绕过crc校验？</p>
</blockquote>
<h2 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h2><p>CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多，但是交换速度却比内存要快得多。</p>
<p>CPU缓存与TLB的区别：</p>
<ul>
<li>TLB：线性地址&lt;—&gt;物理地址</li>
<li>CPU缓存：物理地址&lt;—&gt;具体内容</li>
</ul>
<h3 id="关于PWT-PCD"><a href="#关于PWT-PCD" class="headerlink" title="关于PWT/PCD"></a>关于PWT/PCD</h3><ul>
<li>PWT = 1 时，写Cache的时候也要将数据写入内存中；反之只写入cache</li>
<li>PCD = 1 时，禁止该页写入缓存，直接写内存。比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存在CPU中</li>
</ul>
<h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><ul>
<li>中断的本质是改变CPU执行的路线</li>
<li>中断通常是由CPU外部的输入输出设备（硬件）所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫中断请求</li>
<li>中断请求的目的是虚妄CPU暂时停止执行当前正在执行的程序，转去执行中断请求所对应的中断处理例程（由IDT表决定）</li>
<li>80x86有两条中断请求线：<ul>
<li>非屏蔽中断线，称为NMI</li>
<li>可屏蔽中断线，称为INTR</li>
</ul>
</li>
</ul>
<h3 id="非可屏蔽中断"><a href="#非可屏蔽中断" class="headerlink" title="非可屏蔽中断"></a>非可屏蔽中断</h3><p>当非可屏蔽中断产生时，CPU在执行完当前指令后会进入中断处理程序</p>
<p>非可屏蔽中断不受EFLAG寄存器中IF位的影响，以但发生，CPU必须处理非可屏蔽中断处理程序位于IDT表中的2号位置（80x86中固定为0x2）</p>
<h3 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h3><p>在硬件级，可屏蔽中断是有一块专门的芯片来管理的，通常称为中断控制器。它负责分配中断资源和管理各个中断源发出的中断请求。为了便于标识各个中断请求，中断管理器通常用IRQ（Interrupt Request）后面加上数字来表示不同的中断。</p>
<p>比如：在windows中，时钟中断的IRQ编号为0，也就是IRQ0（在 设备管理器-&gt; 属性  -&gt; 资源 中查看）</p>
<p>如何处理可屏蔽中断：</p>
<table>
<thead>
<tr>
<th>IDT中断号</th>
<th>IRQ</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0x30</td>
<td>IRQ0</td>
<td>时钟中断</td>
</tr>
<tr>
<td>0x31-0x3f</td>
<td>IRQ1-IRQ15</td>
<td>其他硬件设备的中断</td>
</tr>
</tbody></table>
<ul>
<li>如果自己的程序执行时不希望CPU去处理中断，可以使用<code>CLI</code>指令清空EFLAG寄存器的IF位；用<code>STI</code>指令设置EFLAG寄存器中的IF位</li>
<li>硬件中断与IDT表中的对应关系并非固定不变，详细参考：APIC（高级可编程中断控制器）</li>
</ul>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常通常是CPU在执行指令时检测到的某些错误，比如除零、访问无效页面。</p>
<p>中断与异常的区别：</p>
<ul>
<li>中断来自于外部设备，是中断源（比如键盘）发起的，CPU是被动的</li>
<li>异常来自于CPU本身，是CPU主动产生的</li>
<li>INT N虽然被称为软件中断，但其本质是异常。EFLAG的IF位对INT N无效</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>无论是由硬件设备触发的中断还是CPU产生的异常，处理程序都在IDT表中</p>
<p>常见的异常处理程序：</p>
<table>
<thead>
<tr>
<th>错误类型</th>
<th>IDT中断号</th>
</tr>
</thead>
<tbody><tr>
<td>页错误</td>
<td>0xE</td>
</tr>
<tr>
<td>段错误</td>
<td>0xD</td>
</tr>
<tr>
<td>除零错误</td>
<td>0x0</td>
</tr>
<tr>
<td>双重错误</td>
<td>0x8</td>
</tr>
</tbody></table>
<blockquote>
<p>双重错误是指，在某错误的异常处理程序中再次触发异常，即为双重错误</p>
</blockquote>
<h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p>缺页异常的产生：</p>
<ul>
<li>当页表的P=0时</li>
<li>或者向不可写的内存页写入数据时</li>
</ul>
<p>一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统来接管</p>
<p>例如：当物理页不够用时，操作系统会将物理页存在文件里并且将页表P位置零；若对该物理页进行访问时，操作系统发现P 为0则会触发缺页异常处理程序，再对页表中11（转移位）位、10（原型位）位进行检查，如果都是0则意味着该物理页被存在索引为PFN（1-4位）的页面文件里，那么此时就会恢复物理页并把P位置1</p>
<h2 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h2><p>控制寄存器用于控制和确定CPU的操作模式</p>
<p><img src="http://ilinuxkernel.com/wp-content/uploads/2011/06/062111_1434_x86x8664CPU1.png" alt=""></p>
<ul>
<li><p>Cr1 保留</p>
</li>
<li><p>Cr3 页目录表基址 （不同分页形式结构不一样）</p>
</li>
</ul>
<h3 id="Cr0"><a href="#Cr0" class="headerlink" title="Cr0"></a>Cr0</h3><table>
<thead>
<tr>
<th align="center">Bit</th>
<th align="center">Name</th>
<th align="center">Full Name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">PE</td>
<td align="center">Protected Mode Enable</td>
<td align="center">If 1, system is in <a href="https://en.wikipedia.org/wiki/Protected_mode" target="_blank" rel="noopener">protected mode</a>, else system is in <a href="https://en.wikipedia.org/wiki/Real_mode" target="_blank" rel="noopener">real mode</a></td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">MP</td>
<td align="center">Monitor co-processor</td>
<td align="center">Controls interaction of WAIT/FWAIT instructions with TS flag in CR0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">EM</td>
<td align="center">Emulation</td>
<td align="center">If set, no x87 <a href="https://en.wikipedia.org/wiki/Floating-point_unit" target="_blank" rel="noopener">floating-point unit</a> present, if clear, x87 FPU present</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">TS</td>
<td align="center">Task switched</td>
<td align="center">Allows saving x87 task context upon a task switch only after x87 instruction used</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">ET</td>
<td align="center">Extension type</td>
<td align="center">On the 386, it allowed to specify whether the external math coprocessor was an <a href="https://en.wikipedia.org/wiki/80287" target="_blank" rel="noopener">80287</a> or <a href="https://en.wikipedia.org/wiki/80387" target="_blank" rel="noopener">80387</a></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">NE</td>
<td align="center">Numeric error</td>
<td align="center">Enable internal <a href="https://en.wikipedia.org/wiki/X87" target="_blank" rel="noopener">x87</a> floating point error reporting when set, else enables PC style x87 error detection</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">WP</td>
<td align="center">Write protect</td>
<td align="center">When set, the CPU can’t write to read-only pages when privilege level is 0</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">AM</td>
<td align="center">Alignment mask</td>
<td align="center">Alignment check enabled if AM set, AC flag (in <a href="https://en.wikipedia.org/wiki/FLAGS_register" target="_blank" rel="noopener">EFLAGS</a> register) set, and privilege level is 3</td>
</tr>
<tr>
<td align="center">29</td>
<td align="center">NW</td>
<td align="center">Not-write through</td>
<td align="center">Globally enables/disable <a href="https://en.wikipedia.org/wiki/Write_through_cache" target="_blank" rel="noopener">write-through caching</a></td>
</tr>
<tr>
<td align="center">30</td>
<td align="center">CD</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">Cache</a> disable</td>
<td align="center">Globally enables/disable the memory cache</td>
</tr>
<tr>
<td align="center">31</td>
<td align="center">PG</td>
<td align="center">Paging</td>
<td align="center">If 1, enable <a href="https://en.wikipedia.org/wiki/Paging" target="_blank" rel="noopener">paging</a> and use the <a href="https://en.wikipedia.org/wiki/Control_register#CR3" target="_blank" rel="noopener">§ CR3</a> register, else disable paging.</td>
</tr>
</tbody></table>
<ul>
<li>PE = 0 PG = 0 实地址模式</li>
<li>PE = 1 PG = 0 进入保护模式，开启分段机制</li>
<li>PE = 0 PG = 1 不存在这种情况</li>
<li>PE = 1 PG = 1 开启分页机制</li>
</ul>
<h3 id="Cr2"><a href="#Cr2" class="headerlink" title="Cr2"></a>Cr2</h3><p>Contains a value called Page Fault Linear Address (PFLA). When a page fault occurs, the address the program attempted to access is stored in the CR2 register.</p>
<h3 id="Cr3"><a href="#Cr3" class="headerlink" title="Cr3"></a>Cr3</h3><p>Used when <a href="https://en.wikipedia.org/wiki/Virtual_memory" target="_blank" rel="noopener">virtual addressing</a> is enabled, hence when the PG bit is set in CR0. CR3 enables the processor to translate linear addresses into physical addresses by locating the page directory and <a href="https://en.wikipedia.org/wiki/Page_table" target="_blank" rel="noopener">page tables</a> for the current task. Typically, the upper 20 bits of CR3 become the <em>page directory base register</em> (PDBR), which stores the physical address of the first page directory entry. If the PCIDE bit in <a href="https://en.wikipedia.org/wiki/Control_register#CR4" target="_blank" rel="noopener">CR4</a> is set, the lowest 12 bits are used for the <a href="https://en.wikipedia.org/wiki/Process-context_identifier" target="_blank" rel="noopener">process-context identifier</a> (PCID).<a href="https://en.wikipedia.org/wiki/Control_register#cite_note-Intel-Vol3a1-1" target="_blank" rel="noopener">[1]</a></p>
<h3 id="Cr4"><a href="#Cr4" class="headerlink" title="Cr4"></a>Cr4</h3><table>
<thead>
<tr>
<th align="center">Bit</th>
<th align="center">Name</th>
<th align="center">Full Name</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">VME</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Virtual_8086_Mode_Extensions" target="_blank" rel="noopener">Virtual 8086 Mode Extensions</a></td>
<td align="center">If set, enables support for the virtual interrupt flag (VIF) in virtual-8086 mode.</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">PVI</td>
<td align="center">Protected-mode Virtual Interrupts</td>
<td align="center">If set, enables support for the virtual interrupt flag (VIF) in protected mode.</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">TSD</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Timestamp" target="_blank" rel="noopener">Time Stamp</a> Disable</td>
<td align="center">If set, <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter" target="_blank" rel="noopener">RDTSC</a> instruction can only be executed when in <a href="https://en.wikipedia.org/wiki/Ring_(computer_security)" target="_blank" rel="noopener">ring 0</a>, otherwise RDTSC can be used at any privilege level.</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">DE</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Debugging" target="_blank" rel="noopener">Debugging</a> Extensions</td>
<td align="center">If set, enables debug register based breaks on <a href="https://en.wikipedia.org/wiki/Input/output" target="_blank" rel="noopener">I/O</a> space access.</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">PSE</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Page_Size_Extension" target="_blank" rel="noopener">Page Size Extension</a></td>
<td align="center">If unset, page size is 4 KiB, else page size is increased to 4 MiBIf PAE is enabled or the processor is in x86-64 <a href="https://en.wikipedia.org/wiki/Long_mode" target="_blank" rel="noopener">long mode</a> this bit is ignored.<a href="https://en.wikipedia.org/wiki/Control_register#cite_note-AMD64-Vol2-2" target="_blank" rel="noopener">[2]</a></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">PAE</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Physical_Address_Extension" target="_blank" rel="noopener">Physical Address Extension</a></td>
<td align="center">If set, changes page table layout to translate 32-bit virtual addresses into extended 36-bit physical addresses.</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">MCE</td>
<td align="center">Machine Check Exception</td>
<td align="center">If set, enables machine check interrupts to occur.</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">PGE</td>
<td align="center">Page Global Enabled</td>
<td align="center">If set, address translations (PDE or PTE records) may be shared between address spaces.</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">PCE</td>
<td align="center">Performance-Monitoring Counter enable</td>
<td align="center">If set, RDPMC can be executed at any privilege level, else RDPMC can only be used in ring 0.</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">OSFXSR</td>
<td align="center">Operating system support for FXSAVE and FXRSTOR instructions</td>
<td align="center">If set, enables <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions" target="_blank" rel="noopener">Streaming SIMD Extensions</a> (SSE) instructions and fast FPU save &amp; restore.</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">OSXMMEXCPT</td>
<td align="center">Operating System Support for Unmasked SIMD Floating-Point Exceptions</td>
<td align="center">If set, enables unmasked SSE exceptions.</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">UMIP</td>
<td align="center">User-Mode Instruction Prevention</td>
<td align="center">If set, the SGDT, SIDT, SLDT, SMSW and STR instructions cannot be executed if CPL &gt; 0.<a href="https://en.wikipedia.org/wiki/Control_register#cite_note-Intel-Vol3a1-1" target="_blank" rel="noopener">[1]</a></td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">LA57</td>
<td align="center">57-Bit Linear Addresses</td>
<td align="center">If set, enables 5-Level Paging.<a href="https://en.wikipedia.org/wiki/Control_register#cite_note-Intel-5LP-3" target="_blank" rel="noopener">[3]</a><a href="https://en.wikipedia.org/wiki/Control_register#cite_note-Intel-3A-4" target="_blank" rel="noopener">[4]</a>: 2–18</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">VMXE</td>
<td align="center">Virtual Machine Extensions Enable</td>
<td align="center">see <a href="https://en.wikipedia.org/wiki/Intel_VT-x" target="_blank" rel="noopener">Intel VT-x</a> x86 <a href="https://en.wikipedia.org/wiki/Virtualization" target="_blank" rel="noopener">virtualization</a>.</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">SMXE</td>
<td align="center">Safer Mode Extensions Enable</td>
<td align="center">see <a href="https://en.wikipedia.org/wiki/Trusted_Execution_Technology" target="_blank" rel="noopener">Trusted Execution Technology</a> (TXT)</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">FSGSBASE</td>
<td align="center">Enables the instructions RDFSBASE, RDGSBASE, WRFSBASE, and WRGSBASE.</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">PCIDE</td>
<td align="center">PCID Enable</td>
<td align="center">If set, enables process-context identifiers (PCIDs).</td>
</tr>
<tr>
<td align="center">18</td>
<td align="center">OSXSAVE</td>
<td align="center">XSAVE and Processor Extended States Enable</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">20</td>
<td align="center">SMEP<a href="https://en.wikipedia.org/wiki/Control_register#cite_note-5" target="_blank" rel="noopener">[5]</a></td>
<td align="center">Supervisor Mode Execution Protection Enable</td>
<td align="center">If set, execution of code in a higher <a href="https://en.wikipedia.org/wiki/Protection_ring" target="_blank" rel="noopener">ring</a> generates a <a href="https://en.wikipedia.org/wiki/Fault_(computing)" target="_blank" rel="noopener">fault</a>.</td>
</tr>
<tr>
<td align="center">21</td>
<td align="center">SMAP</td>
<td align="center"><a href="https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention" target="_blank" rel="noopener">Supervisor Mode Access Prevention</a> Enable</td>
<td align="center">If set, access of data in a higher ring generates a <a href="https://en.wikipedia.org/wiki/Fault_(computing)" target="_blank" rel="noopener">fault</a>.<a href="https://en.wikipedia.org/wiki/Control_register#cite_note-6" target="_blank" rel="noopener">[6]</a></td>
</tr>
<tr>
<td align="center">22</td>
<td align="center">PKE</td>
<td align="center">Protection Key Enable</td>
<td align="center">See Intel 64 and IA-32 Architectures Software Developer’s Manual.</td>
</tr>
<tr>
<td align="center">23</td>
<td align="center">CET</td>
<td align="center">Control-flow Enforcement Technology</td>
<td align="center">If set, enables control-flow enforcement technology.<a href="https://en.wikipedia.org/wiki/Control_register#cite_note-Intel-3A-4" target="_blank" rel="noopener">[4]</a>: 2–19</td>
</tr>
<tr>
<td align="center">24</td>
<td align="center">PKS</td>
<td align="center">Enable Protection Keys for Supervisor-Mode Pages</td>
<td align="center">If set, each supervisor-mode linear address is associated with a <a href="https://en.wikipedia.org/wiki/Memory_protection#Protection_keys" target="_blank" rel="noopener">protection key</a> when 4-level or 5-level paging is in use.<a href="https://en.wikipedia.org/wiki/Control_register#cite_note-Intel-3A-4" target="_blank" rel="noopener">[4]</a>: 2–19</td>
</tr>
</tbody></table>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="API-3环进0环"><a href="#API-3环进0环" class="headerlink" title="API 3环进0环"></a>API 3环进0环</h2><h3 id="KUSER-SHARED-DATA"><a href="#KUSER-SHARED-DATA" class="headerlink" title="_KUSER_SHARED_DATA"></a>_KUSER_SHARED_DATA</h3><ul>
<li>用于用户态和内核态共享数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:000000018009CE20 4C 8B D1                          mov     r10, rcx        ; NtReadFile</span><br><span class="line">.text:000000018009CE23 B8 06 00 00 00                    mov     eax, 6</span><br><span class="line">.text:000000018009CE28 F6 04 25 08 03 FE+                test    byte ptr ds:7FFE0308h, 1 ; 判断CPU是否支持快速系统调用</span><br><span class="line">.text:000000018009CE28 7F 01</span><br><span class="line">.text:000000018009CE30 75 03                             jnz     short loc_18009CE35 ; Jump if Not Zero (ZF&#x3D;0)</span><br><span class="line">.text:000000018009CE32 0F 05                             syscall                 ; Low latency system call</span><br><span class="line">.text:000000018009CE34 C3                                retn                    ; Return Near from Procedure</span><br><span class="line">.text:000000018009CE35                   ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000018009CE35</span><br><span class="line">.text:000000018009CE35                   loc_18009CE35:                          ; CODE XREF: NtReadFile+10↑j</span><br><span class="line">.text:000000018009CE35 CD 2E                             int     2Eh             ; DOS 2+ internal - EXECUTE COMMAND</span><br><span class="line">.text:000000018009CE35                                                           ; DS:SI -&gt; counted CR-terminated command string</span><br><span class="line">.text:000000018009CE37 C3                                retn                    ; Return Near from Procedure</span><br></pre></td></tr></table></figure>

<p>windbg中查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2:002&gt; dt _KUSER_SHARED_DATA 7FFE0000 SystemCall</span><br><span class="line">ntdll!_KUSER_SHARED_DATA</span><br><span class="line">   +0x308 SystemCall : 0</span><br></pre></td></tr></table></figure>

<h3 id="修改寄存器"><a href="#修改寄存器" class="headerlink" title="修改寄存器"></a>修改寄存器</h3><ol>
<li>cs的权限从3变为0</li>
<li>ss与cs权限永远一致，即ss权限也变为0 </li>
<li>权限发生切换，栈也一定需要切换，需要新的esp</li>
<li>进0环后代码的位置，需要新的eip</li>
</ol>
<h3 id="中断进0环"><a href="#中断进0环" class="headerlink" title="中断进0环"></a>中断进0环</h3><ul>
<li>固定中断号为0x2e</li>
<li>cs eip 由IDT提供，esp ss 由TSS提供</li>
<li>进入0环后执行的内核函数：nt!KiSystemService</li>
</ul>
<h3 id="sysenter进0环"><a href="#sysenter进0环" class="headerlink" title="sysenter进0环"></a>sysenter进0环</h3><ul>
<li>cs esp eip由MSR寄存器提供（ss为cs + 8）</li>
<li>进入0环后执行的内核函数：nt!KiFastCallEntry</li>
</ul>
<h3 id="sysenter-和-中断-进0环的区别"><a href="#sysenter-和-中断-进0环的区别" class="headerlink" title="sysenter 和 中断 进0环的区别"></a>sysenter 和 中断 进0环的区别</h3><p>相同点：</p>
<ul>
<li>目的都是找到内核态需要的cs ss eip esp</li>
</ul>
<p>sysenter/快速调用的优点：</p>
<ul>
<li>中断需要的cs eip在IDT表中，需要查内存（ss与esp由TSS提供），速度慢</li>
<li>如果cpu支持快速系统调用，则会在启动时提前把内核态的cs ss esp eip储存到MSR寄存器中，sysenter执行时，直接交换寄存器的值，速度相对快</li>
</ul>
<h3 id="64位syscall"><a href="#64位syscall" class="headerlink" title="64位syscall"></a>64位syscall</h3><p><img src="https://p1.ssl.qhimg.com/t0149995eff6ad6f1be.png" alt=""></p>
<p><img src="https://p3.ssl.qhimg.com/t01e1fb351bf197cf56.png" alt=""></p>
<ul>
<li><p>STAR (0xC0000081) - Ring 0 and Ring 3 Segment bases, as well as SYSCALL EIP. Low 32 bits = SYSCALL EIP, bits 32-47 are kernel segment base, bits 48-63 are user segment base.</p>
</li>
<li><p>LSTAR (0xC0000082) - The kernel’s RIP SYSCALL entry for 64 bit software.</p>
</li>
<li><p>CSTAR (0xC0000083) - The kernel’s RIP for SYSCALL in compatibility mode.</p>
</li>
<li><p>SFMASK (0xC0000084) - The low 32 bits are the SYSCALL flag mask. If a bit in this is set, the corresponding bit in rFLAGS is cleared.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; rdmsr c0000082</span><br><span class="line">msr[c0000082] &#x3D; fffff803&#96;18159d00</span><br><span class="line">kd&gt; u fffff803&#96;18159d00</span><br><span class="line">nt!KiSystemCall64:</span><br><span class="line">fffff803&#96;18159d00 0f01f8          swapgs</span><br><span class="line">fffff803&#96;18159d03 654889242510000000 mov   qword ptr gs:[10h],rsp</span><br><span class="line">fffff803&#96;18159d0c 65488b2425a8010000 mov   rsp,qword ptr gs:[1A8h]</span><br><span class="line">fffff803&#96;18159d15 6a2b            push    2Bh</span><br><span class="line">fffff803&#96;18159d17 65ff342510000000 push    qword ptr gs:[10h]</span><br><span class="line">fffff803&#96;18159d1f 4153            push    r11</span><br><span class="line">fffff803&#96;18159d21 6a33            push    33h</span><br><span class="line">fffff803&#96;18159d23 51              push    rcx</span><br></pre></td></tr></table></figure>

<h2 id="保存现场"><a href="#保存现场" class="headerlink" title="保存现场"></a>保存现场</h2><h3 id="Ktrap-frame"><a href="#Ktrap-frame" class="headerlink" title="_Ktrap_frame"></a>_Ktrap_frame</h3><p>进入0环后，存入所有用户态的寄存器</p>
<p>位于kthread中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _Ktrap_frame</span><br><span class="line">ntdll!_KTRAP_FRAME</span><br><span class="line">   +0x000 DbgEbp           : Uint4B</span><br><span class="line">   +0x004 DbgEip           : Uint4B</span><br><span class="line">   +0x008 DbgArgMark       : Uint4B</span><br><span class="line">   +0x00c TempSegCs        : Uint2B</span><br><span class="line">   +0x00e Logging          : UChar</span><br><span class="line">   +0x00f FrameType        : UChar</span><br><span class="line">   +0x010 TempEsp          : Uint4B</span><br><span class="line">   +0x014 Dr0              : Uint4B</span><br><span class="line">   +0x018 Dr1              : Uint4B</span><br><span class="line">   +0x01c Dr2              : Uint4B</span><br><span class="line">   +0x020 Dr3              : Uint4B</span><br><span class="line">   +0x024 Dr6              : Uint4B</span><br><span class="line">   +0x028 Dr7              : Uint4B</span><br><span class="line">   +0x02c SegGs            : Uint4B</span><br><span class="line">   +0x030 SegEs            : Uint4B</span><br><span class="line">   +0x034 SegDs            : Uint4B</span><br><span class="line">   +0x038 Edx              : Uint4B</span><br><span class="line">   +0x03c Ecx              : Uint4B</span><br><span class="line">   +0x040 Eax              : Uint4B</span><br><span class="line">   +0x044 PreviousPreviousMode : UChar</span><br><span class="line">   +0x045 EntropyQueueDpc  : UChar</span><br><span class="line">   +0x046 NmiMsrIbrs       : UChar</span><br><span class="line">   +0x046 Reserved1        : UChar</span><br><span class="line">   +0x047 PreviousIrql     : UChar</span><br><span class="line">   +0x048 MxCsr            : Uint4B</span><br><span class="line">   +0x04c ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x050 SegFs            : Uint4B</span><br><span class="line">   +0x054 Edi              : Uint4B</span><br><span class="line">   +0x058 Esi              : Uint4B</span><br><span class="line">   +0x05c Ebx              : Uint4B</span><br><span class="line">   +0x060 Ebp              : Uint4B</span><br><span class="line">   +0x064 ErrCode          : Uint4B</span><br><span class="line">   +0x068 Eip              : Uint4B</span><br><span class="line">   +0x06c SegCs            : Uint4B</span><br><span class="line">   +0x070 EFlags           : Uint4B</span><br><span class="line">   +0x074 HardwareEsp      : Uint4B</span><br><span class="line">   +0x078 HardwareSegSs    : Uint4B</span><br><span class="line">   +0x07c V86Es            : Uint4B</span><br><span class="line">   +0x080 V86Ds            : Uint4B</span><br><span class="line">   +0x084 V86Fs            : Uint4B</span><br><span class="line">   +0x088 V86Gs            : Uint4B</span><br></pre></td></tr></table></figure>

<h3 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h3><p>描述线程相关状态，其中_KTHREAD相对重要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; dt _ETHREAD</span><br><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x280 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x288 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x288 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x290 ChargeOnlySession : Ptr32 Void</span><br><span class="line">   +0x294 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x294 ForwardLinkShadow : Ptr32 Void</span><br><span class="line">   +0x298 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x29c TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x29c ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x29c KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x2a0 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x2a4 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x2ac Cid              : _CLIENT_ID</span><br><span class="line">   ·</span><br><span class="line">   ·</span><br><span class="line">   ·</span><br></pre></td></tr></table></figure>

<h3 id="KPCR-processor-control-region"><a href="#KPCR-processor-control-region" class="headerlink" title="KPCR(processor control region)"></a>KPCR(processor control region)</h3><p>CPU控制区，描述当前CPU的状态</p>
<p>查看CPU数量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd KeNumberProcessors</span><br></pre></td></tr></table></figure>

<p>查看其他CPU的KPCR： (此处显示结尾地址，应减去相应KPCR结构大小)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq KiProcessorBlock</span><br></pre></td></tr></table></figure>

<h3 id="KiSystemCall64"><a href="#KiSystemCall64" class="headerlink" title="KiSystemCall64"></a>KiSystemCall64</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.text:000000014014CD00                   KiSystemCall64  proc near               ; DATA XREF: .pdata:0000000140344818↓o</span><br><span class="line">.text:000000014014CD00                                                           ; KiInitializeBootStructures+12E↓o</span><br><span class="line">.text:000000014014CD00</span><br><span class="line">.text:000000014014CD00                   var_58          &#x3D; byte ptr -58h</span><br><span class="line">.text:000000014014CD00                   var_30          &#x3D; qword ptr -30h</span><br><span class="line">.text:000000014014CD00                   var_28          &#x3D; qword ptr -28h</span><br><span class="line">.text:000000014014CD00                   var_20          &#x3D; qword ptr -20h</span><br><span class="line">.text:000000014014CD00                   var_18          &#x3D; qword ptr -18h</span><br><span class="line">.text:000000014014CD00                   var_10          &#x3D; qword ptr -10h</span><br><span class="line">.text:000000014014CD00                   arg_78          &#x3D; byte ptr  80h</span><br><span class="line">.text:000000014014CD00                   arg_F8          &#x3D; qword ptr  100h</span><br><span class="line">.text:000000014014CD00</span><br><span class="line">.text:000000014014CD00                   ; __unwind &#123; &#x2F;&#x2F; KiSystemServiceHandler</span><br><span class="line">.text:000000014014CD00 0F 01 F8                          swapgs                  ; Exchange GS base with KernelGSBase MSR</span><br><span class="line">.text:000000014014CD03 65 48 89 24 25 10+                mov     gs:10h, rsp</span><br><span class="line">.text:000000014014CD03 00 00 00</span><br><span class="line">.text:000000014014CD0C 65 48 8B 24 25 A8+                mov     rsp, gs:1A8h</span><br><span class="line">.text:000000014014CD0C 01 00 00</span><br><span class="line">.text:000000014014CD15 6A 2B                             push    2Bh ; &#39;+&#39;       ; ss</span><br><span class="line">.text:000000014014CD17 65 FF 34 25 10 00+                push    qword ptr gs:10h ; rsp</span><br><span class="line">.text:000000014014CD17 00 00</span><br><span class="line">.text:000000014014CD1F 41 53                             push    r11             ; eflags</span><br><span class="line">.text:000000014014CD21 6A 33                             push    33h ; &#39;3&#39;       ; cs</span><br><span class="line">.text:000000014014CD23 51                                push    rcx             ; rip</span><br><span class="line">.text:000000014014CD24 49 8B CA                          mov     rcx, r10</span><br><span class="line">.text:000000014014CD27 48 83 EC 08                       sub     rsp, 8          ; Integer Subtraction</span><br><span class="line">.text:000000014014CD2B 55                                push    rbp             ; rbp</span><br><span class="line">.text:000000014014CD2C 48 81 EC 58 01 00+                sub     rsp, 158h       ; rsp &#x3D; _KTRAP_FRAME</span><br><span class="line">.text:000000014014CD2C 00</span><br><span class="line">.text:000000014014CD33 48 8D AC 24 80 00+                lea     rbp, [rsp+arg_78] ; rbp &#x3D; _KTRAP_FRAME + 0x80</span><br><span class="line">.text:000000014014CD33 00 00</span><br><span class="line">.text:000000014014CD3B 48 89 9D C0 00 00+                mov     [rbp+0C0h], rbx ; rbx</span><br><span class="line">.text:000000014014CD3B 00</span><br><span class="line">.text:000000014014CD42 48 89 BD C8 00 00+                mov     [rbp+0C8h], rdi ; rdi</span><br><span class="line">.text:000000014014CD42 00</span><br><span class="line">.text:000000014014CD49 48 89 B5 D0 00 00+                mov     [rbp+0D0h], rsi ; rsi</span><br><span class="line">.text:000000014014CD49 00</span><br><span class="line">.text:000000014014CD50</span><br><span class="line">.text:000000014014CD50                   KiSystemServiceUser:                    ; DATA XREF: KiSystemService+2F↑o</span><br><span class="line">.text:000000014014CD50 C6 45 AB 02                       mov     byte ptr [rbp-55h], 2 ; ExceptionActive &#x3D; 2</span><br></pre></td></tr></table></figure>

<h3 id="KiSystemService"><a href="#KiSystemService" class="headerlink" title="KiSystemService"></a>KiSystemService</h3><p>KiSystemCall64的阉割版</p>
<p>ss eflags cs rip 已经在中断时保存，rsp通过TSS取得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.text:000000014014CA00                   KiSystemService proc near               ; DATA XREF: .pdata:00000001403447E8↓o</span><br><span class="line">.text:000000014014CA00                                                           ; INITDATA:0000000140716308↓o</span><br><span class="line">.text:000000014014CA00</span><br><span class="line">.text:000000014014CA00                   var_E8          &#x3D; byte ptr -0E8h</span><br><span class="line">.text:000000014014CA00</span><br><span class="line">.text:000000014014CA00 0F 01 F8                          swapgs                  ; Exchange GS base with KernelGSBase MSR</span><br><span class="line">.text:000000014014CA03 49 8B CA                          mov     rcx, r10</span><br><span class="line">.text:000000014014CA06 48 83 EC 08                       sub     rsp, 8          ; Integer Subtraction</span><br><span class="line">.text:000000014014CA0A 55                                push    rbp</span><br><span class="line">.text:000000014014CA0B 48 81 EC 58 01 00+                sub     rsp, 158h       ; Integer Subtraction</span><br><span class="line">.text:000000014014CA0B 00</span><br><span class="line">.text:000000014014CA12 48 8D AC 24 80 00+                lea     rbp, [rsp+168h+var_E8] ; 80h</span><br><span class="line">.text:000000014014CA12 00 00</span><br><span class="line">.text:000000014014CA1A 48 89 9D C0 00 00+                mov     [rbp+0C0h], rbx</span><br><span class="line">.text:000000014014CA1A 00</span><br><span class="line">.text:000000014014CA21 48 89 BD C8 00 00+                mov     [rbp+0C8h], rdi</span><br><span class="line">.text:000000014014CA21 00</span><br><span class="line">.text:000000014014CA28 48 89 B5 D0 00 00+                mov     [rbp+0D0h], rsi</span><br><span class="line">.text:000000014014CA28 00</span><br><span class="line">.text:000000014014CA2F 4C 8D 1D 1A 03 00+                lea     r11, KiSystemServiceUser ; ExceptionActive &#x3D; 2</span><br><span class="line">.text:000000014014CA2F 00</span><br><span class="line">.text:000000014014CA36 41 FF E3                          jmp     r11             ; Indirect Near Jump</span><br><span class="line">.text:000000014014CA39                   ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000014014CA39 C3                                retn                    ; Return Near from Procedure</span><br><span class="line">.text:000000014014CA39                   KiSystemService endp</span><br></pre></td></tr></table></figure>

<p>关于后面的分析需要提前知道下面两个东西</p>
<h2 id="系统服务表"><a href="#系统服务表" class="headerlink" title="系统服务表"></a>系统服务表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_SERVICE_TABLE</span>&#123;</span></span><br><span class="line">    PVOID ServiceTableBase;<span class="comment">//地址表</span></span><br><span class="line">    PVOID ServiceCounterTableBase;<span class="comment">//该表被访问次数</span></span><br><span class="line">    ULONGLONG NumberOfServices;<span class="comment">//函数个数</span></span><br><span class="line">    PVOID ParamTableBase;<span class="comment">//参数个数表</span></span><br><span class="line">&#125; SYSTEM_SERVICE_TABLE, *PSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure>

<h2 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h2><p>SSDT全称为System Service Descriptor Table，系统服务描述表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dq nt!KeServiceDescriptorTable</span><br><span class="line">fffff802&#96;6f3fe780  fffff802&#96;6f341150 00000000&#96;00000000</span><br><span class="line">fffff802&#96;6f3fe790  00000000&#96;000001bc fffff802&#96;6f341f34</span><br><span class="line">fffff802&#96;6f3fe7a0  00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line">fffff802&#96;6f3fe7b0  00000000&#96;00000000 00000000&#96;00000000</span><br><span class="line"></span><br><span class="line">kd&gt; dq nt!KeServiceDescriptorTableShadow</span><br><span class="line">fffff802&#96;6f3fe740  fffff802&#96;6f341150 00000000&#96;00000000</span><br><span class="line">fffff802&#96;6f3fe750  00000000&#96;000001bc fffff802&#96;6f341f34</span><br><span class="line">fffff802&#96;6f3fe760  fffff961&#96;efd89000 00000000&#96;00000000</span><br><span class="line">fffff802&#96;6f3fe770  00000000&#96;0000046f fffff961&#96;efd8b7ec</span><br></pre></td></tr></table></figure>

<p>在xp中SSDT有4个表，后面3个都是空的，这里盲猜有2个表</p>
<p>SSDT中包含ntoskrl中的函数，SSDT Shadow中额外包含win32k中的函数</p>
<h2 id="KiSystemServiceUser"><a href="#KiSystemServiceUser" class="headerlink" title="KiSystemServiceUser"></a>KiSystemServiceUser</h2><p>可以看到不管是中断还是快速调用都会跳到KiSystemServiceUser</p>
<p>这里主要判断是否处于调试模式，如果是则保存调试相关寄存器Dr0-Dr7等一系列操作，如果不是则继续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.text:000000014014CD50                   KiSystemServiceUser:                    ; DATA XREF: KiSystemService+2F↑o</span><br><span class="line">.text:000000014014CD50 C6 45 AB 02                       mov     byte ptr [rbp-55h], 2 ; ExceptionActive &#x3D; 2</span><br><span class="line">.text:000000014014CD54 65 48 8B 1C 25 88+                mov     rbx, gs:188h    ; _KTHREAD</span><br><span class="line">.text:000000014014CD54 01 00 00</span><br><span class="line">.text:000000014014CD5D 0F 0D 8B 90 00 00+                prefetchw byte ptr [rbx+90h] ; Trap_Frame</span><br><span class="line">.text:000000014014CD5D 00</span><br><span class="line">.text:000000014014CD64 0F AE 5D AC                       stmxcsr dword ptr [rbp-54h] ; Trap_Frame.MxCsr</span><br><span class="line">.text:000000014014CD68 65 0F AE 14 25 80+                ldmxcsr dword ptr gs:180h ; KPCRB.MxCsr</span><br><span class="line">.text:000000014014CD68 01 00 00</span><br><span class="line">.text:000000014014CD71 80 7B 03 00                       cmp     byte ptr [rbx+3], 0 ; DebugActive</span><br><span class="line">.text:000000014014CD75 66 C7 85 80 00 00+                mov     word ptr [rbp+80h], 0 ; Dr7 &#x3D; 0</span><br><span class="line">.text:000000014014CD75 00 00 00</span><br><span class="line">.text:000000014014CD7E 0F 84 9A 00 00 00                 jz      loc_14014CE1E   ; 不处于调试就跳转</span><br><span class="line">.text:000000014014CD84 48 89 45 B0                       mov     [rbp-50h], rax</span><br><span class="line">.text:000000014014CD88 48 89 4D B8                       mov     [rbp-48h], rcx</span><br><span class="line">.text:000000014014CD8C 48 89 55 C0                       mov     [rbp-40h], rdx</span><br><span class="line">.text:000000014014CD90 F6 43 03 03                       test    byte ptr [rbx+3], 3 ; Logical Compare</span><br><span class="line">.text:000000014014CD94 4C 89 45 C8                       mov     [rbp-38h], r8</span><br><span class="line">.text:000000014014CD98 4C 89 4D D0                       mov     [rbp-30h], r9</span><br><span class="line">.text:000000014014CD9C 74 05                             jz      short loc_14014CDA3 ; Jump if Zero (ZF&#x3D;1)</span><br><span class="line">.text:000000014014CD9E E8 AD 5E FF FF                    call    KiSaveDebugRegisterState ; Call Procedure</span><br></pre></td></tr></table></figure>

<p>这里首先保存FirstArgument SystemCallNumber TrapFrame</p>
<p>然后判断SystemCallNumber的第13位是否为1，如果是则是一个win32k调用走SSDT Shadow</p>
<p>接着获取SSDT中的函数地址表，在64位系统中这里并不是真正的地址而是需要经过一段计算FunAddr = ssdt[0] + *(ssdt[0]+4 * Index) &gt;&gt; 4</p>
<p>经过一些判断后最终跳转到KiSystemServiceCopyEnd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">.text:000000014014CE1E                   loc_14014CE1E:                          ; CODE XREF: KiSystemCall64+7E↑j</span><br><span class="line">.text:000000014014CE1E FB                                sti                     ; Set Interrupt Flag</span><br><span class="line">.text:000000014014CE1F 48 89 8B 88 00 00+                mov     [rbx+88h], rcx  ; FirstArgument</span><br><span class="line">.text:000000014014CE1F 00</span><br><span class="line">.text:000000014014CE26 89 83 80 00 00 00                 mov     [rbx+80h], eax  ; SystemCallNumber</span><br><span class="line">.text:000000014014CE2C 0F 1F 40 00                       nop     dword ptr [rax+00h] ; No Operation</span><br><span class="line">.text:000000014014CE30</span><br><span class="line">.text:000000014014CE30                   KiSystemServiceStart:                   ; DATA XREF: KiServiceInternal+5A↑o</span><br><span class="line">.text:000000014014CE30                                                           ; .data:00000001402C4338↓o</span><br><span class="line">.text:000000014014CE30 48 89 A3 90 00 00+                mov     [rbx+90h], rsp  ; TrapFrame</span><br><span class="line">.text:000000014014CE30 00</span><br><span class="line">.text:000000014014CE37 8B F8                             mov     edi, eax</span><br><span class="line">.text:000000014014CE39 C1 EF 07                          shr     edi, 7          ; Shift Logical Right</span><br><span class="line">.text:000000014014CE3C 83 E7 20                          and     edi, 20h        ; Logical AND</span><br><span class="line">.text:000000014014CE3F 25 FF 0F 00 00                    and     eax, 0FFFh      ; Logical AND</span><br><span class="line">.text:000000014014CE44</span><br><span class="line">.text:000000014014CE44                   KiSystemServiceRepeat:                  ; CODE XREF: KiSystemCall64+490↓j</span><br><span class="line">.text:000000014014CE44 4C 8D 15 35 29 23+                lea     r10, KeServiceDescriptorTable ; Load Effective Address</span><br><span class="line">.text:000000014014CE44 00</span><br><span class="line">.text:000000014014CE4B 4C 8D 1D EE 28 23+                lea     r11, KeServiceDescriptorTableShadow ; Load Effective Address</span><br><span class="line">.text:000000014014CE4B 00</span><br><span class="line">.text:000000014014CE52 F7 43 78 40 00 00+                test    dword ptr [rbx+78h], 40h ; KTHREAD.GuiThread</span><br><span class="line">.text:000000014014CE52 00</span><br><span class="line">.text:000000014014CE59 4D 0F 45 D3                       cmovnz  r10, r11        ; Move if Not Zero (ZF&#x3D;0)</span><br><span class="line">.text:000000014014CE5D 42 3B 44 17 10                    cmp     eax, [rdi+r10+10h] ; typedef struct _SYSTEM_SERVICE_TABLE&#123;</span><br><span class="line">.text:000000014014CE5D                                                           ;     PVOID ServiceTableBase;&#x2F;&#x2F;地址表</span><br><span class="line">.text:000000014014CE5D                                                           ;     PVOID ServiceCounterTableBase;&#x2F;&#x2F;该表被访问次数</span><br><span class="line">.text:000000014014CE5D                                                           ;     ULONGLONG NumberOfServices;&#x2F;&#x2F;函数个数</span><br><span class="line">.text:000000014014CE5D                                                           ;     PVOID ParamTableBase;&#x2F;&#x2F;参数个数表</span><br><span class="line">.text:000000014014CE5D                                                           ; &#125; SYSTEM_SERVICE_TABLE, *PSYSTEM_SERVICE_TABLE;</span><br><span class="line">.text:000000014014CE62 0F 83 EF 02 00 00                 jnb     loc_14014D157   ; Jump if Not Below (CF&#x3D;0)</span><br><span class="line">.text:000000014014CE68 4E 8B 14 17                       mov     r10, [rdi+r10]</span><br><span class="line">.text:000000014014CE6C 4D 63 1C 82                       movsxd  r11, dword ptr [r10+rax*4] ; 64位下需要计算得到真实的地址FunAddr &#x3D;ssdt[0] + *(ssdt[0]+4 * Index)&gt;&gt;4</span><br><span class="line">.text:000000014014CE70 49 8B C3                          mov     rax, r11</span><br><span class="line">.text:000000014014CE73 49 C1 FB 04                       sar     r11, 4          ; Shift Arithmetic Right</span><br><span class="line">.text:000000014014CE77 4D 03 D3                          add     r10, r11        ; Add</span><br><span class="line">.text:000000014014CE7A 83 FF 20                          cmp     edi, 20h ; &#39; &#39;  ; Compare Two Operands</span><br><span class="line">.text:000000014014CE7D 75 51                             jnz     short loc_14014CED0 ; Jump if Not Zero (ZF&#x3D;0)</span><br><span class="line">.text:000000014014CE7F 4C 8B 9B F0 00 00+                mov     r11, [rbx+0F0h] ; teb</span><br><span class="line">.text:000000014014CE7F 00</span><br><span class="line">.text:000000014014CE86</span><br><span class="line">.text:000000014014CE86                   KiSystemServiceGdiTebAccess:            ; DATA XREF: KiSystemServiceHandler+D↑o</span><br><span class="line">.text:000000014014CE86 41 83 BB 40 17 00+                cmp     dword ptr [r11+1740h], 0 ; teb.GdiBatchCount</span><br><span class="line">.text:000000014014CE86 00 00</span><br><span class="line">.text:000000014014CE8E 74 40                             jz      short loc_14014CED0 ; Jump if Zero (ZF&#x3D;1)</span><br><span class="line">.text:000000014014CE90 48 89 45 B0                       mov     [rbp-50h], rax</span><br><span class="line">.text:000000014014CE94 48 89 4D B8                       mov     [rbp-48h], rcx</span><br><span class="line">.text:000000014014CE98 48 89 55 C0                       mov     [rbp-40h], rdx</span><br><span class="line">.text:000000014014CE9C 49 8B D8                          mov     rbx, r8</span><br><span class="line">.text:000000014014CE9F 49 8B F9                          mov     rdi, r9</span><br><span class="line">.text:000000014014CEA2 49 8B F2                          mov     rsi, r10</span><br><span class="line">.text:000000014014CEA5 B9 07 00 00 00                    mov     ecx, 7</span><br><span class="line">.text:000000014014CEAA 33 D2                             xor     edx, edx        ; Logical Exclusive OR</span><br><span class="line">.text:000000014014CEAC 4D 33 C0                          xor     r8, r8          ; Logical Exclusive OR</span><br><span class="line">.text:000000014014CEAF 4D 33 C9                          xor     r9, r9          ; Logical Exclusive OR</span><br><span class="line">.text:000000014014CEB2 E8 E9 0F 2D 00                    call    PsInvokeWin32Callout ; Call Procedure</span><br><span class="line">.text:000000014014CEB7 48 8B 45 B0                       mov     rax, [rbp-50h]</span><br><span class="line">.text:000000014014CEBB 48 8B 4D B8                       mov     rcx, [rbp-48h]</span><br><span class="line">.text:000000014014CEBF 48 8B 55 C0                       mov     rdx, [rbp-40h]</span><br><span class="line">.text:000000014014CEC3 4C 8B C3                          mov     r8, rbx</span><br><span class="line">.text:000000014014CEC6 4C 8B CF                          mov     r9, rdi</span><br><span class="line">.text:000000014014CEC9 4C 8B D6                          mov     r10, rsi</span><br><span class="line">.text:000000014014CECC 0F 1F 40 00                       nop     dword ptr [rax+00h] ; No Operation</span><br><span class="line">.text:000000014014CED0</span><br><span class="line">.text:000000014014CED0                   loc_14014CED0:                          ; CODE XREF: KiSystemCall64+17D↑j</span><br><span class="line">.text:000000014014CED0                                                           ; KiSystemCall64+18E↑j</span><br><span class="line">.text:000000014014CED0 83 E0 0F                          and     eax, 0Fh        ; Logical AND</span><br><span class="line">.text:000000014014CED3 0F 84 B7 00 00 00                 jz      KiSystemServiceCopyEnd ; Jump if Zero (ZF&#x3D;1)</span><br><span class="line">.text:000000014014CED9 C1 E0 03                          shl     eax, 3          ; Shift Logical Left</span><br><span class="line">.text:000000014014CEDC 48 8D 64 24 90                    lea     rsp, [rsp-70h]  ; Load Effective Address</span><br><span class="line">.text:000000014014CEE1 48 8D 7C 24 18                    lea     rdi, [rsp+70h+var_58] ; Load Effective Address</span><br><span class="line">.text:000000014014CEE6 48 8B B5 00 01 00+                mov     rsi, [rbp+100h] ; rsp</span><br><span class="line">.text:000000014014CEE6 00</span><br><span class="line">.text:000000014014CEED 48 8D 76 20                       lea     rsi, [rsi+20h]  ; Load Effective Address</span><br><span class="line">.text:000000014014CEF1 F6 85 F0 00 00 00+                test    byte ptr [rbp+0F0h], 1 ; cs</span><br><span class="line">.text:000000014014CEF1 01</span><br><span class="line">.text:000000014014CEF8 74 16                             jz      short loc_14014CF10 ; Jump if Zero (ZF&#x3D;1)</span><br><span class="line">.text:000000014014CEFA 48 3B 35 FF 22 23+                cmp     rsi, cs:MmUserProbeAddress ; 用户态最大地址</span><br><span class="line">.text:000000014014CEFA 00</span><br><span class="line">.text:000000014014CF01 48 0F 43 35 F7 22+                cmovnb  rsi, cs:MmUserProbeAddress ; Move if Not Below (CF&#x3D;0)</span><br><span class="line">.text:000000014014CF01 23 00</span><br><span class="line">.text:000000014014CF09 0F 1F 80 00 00 00+                nop     dword ptr [rax+00000000h] ; No Operation</span><br><span class="line">.text:000000014014CF09 00</span><br><span class="line">.text:000000014014CF10</span><br><span class="line">.text:000000014014CF10                   loc_14014CF10:                          ; CODE XREF: KiSystemCall64+1F8↑j</span><br><span class="line">.text:000000014014CF10 4C 8D 1D 79 00 00+                lea     r11, KiSystemServiceCopyEnd ; Load Effective Address</span><br><span class="line">.text:000000014014CF10 00</span><br><span class="line">.text:000000014014CF17 4C 2B D8                          sub     r11, rax        ; Integer Subtraction</span><br><span class="line">.text:000000014014CF1A 41 FF E3                          jmp     r11             ; Indirect Near Jump</span><br></pre></td></tr></table></figure>

<p>KiSystemServiceCopyEnd:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:000000014014CF90                   KiSystemServiceCopyEnd:                 ; CODE XREF: KiSystemCall64+1D3↑j</span><br><span class="line">.text:000000014014CF90                                                           ; DATA XREF: KiSystemServiceHandler+27↑o</span><br><span class="line">.text:000000014014CF90                                                           ; KiSystemCall64:loc_14014CF10↑o</span><br><span class="line">.text:000000014014CF90 F7 05 EE 22 23 00+                test    dword ptr cs:PerfGlobalGroupMask+8, 40h ; Logical Compare</span><br><span class="line">.text:000000014014CF90 40 00 00 00</span><br><span class="line">.text:000000014014CF9A 0F 85 55 02 00 00                 jnz     loc_14014D1F5   ; Jump if Not Zero (ZF&#x3D;0)</span><br><span class="line">.text:000000014014CFA0 41 FF D2                          call    r10             ; Indirect Call Near Procedure</span><br><span class="line">.text:000000014014CFA3</span><br><span class="line">.text:000000014014CFA3                   loc_14014CFA3:                          ; CODE XREF: KiSystemCall64+54A↓j</span><br><span class="line">.text:000000014014CFA3 65 FF 04 25 38 2E+                inc     dword ptr gs:2E38h ; KeSystemCalls</span><br><span class="line">.text:000000014014CFA3 00 00</span><br><span class="line">.text:000000014014CFAB</span><br><span class="line">.text:000000014014CFAB                   KiSystemServiceExit:                    ; CODE XREF: KiSystemCall64+B2↑j</span><br></pre></td></tr></table></figure>

<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="EPROCESS进程结构体"><a href="#EPROCESS进程结构体" class="headerlink" title="EPROCESS进程结构体"></a>EPROCESS进程结构体</h2><p>每个windows进程在0环都有一个对应的结构体：EPROCESS，这个结构体包含了进程所有重要的信息。</p>
<h3 id="KPROCESS"><a href="#KPROCESS" class="headerlink" title="KPROCESS"></a>KPROCESS</h3><ul>
<li>Header :_DISPATCHER_HEADER <ul>
<li>内核对象结构体带有此字段即为可等待对象，比如Mutex互斥体，Event事件等（WaitForSingleObject）</li>
</ul>
</li>
<li>DirectoryTableBase<ul>
<li>页目录表的基址，进程切换时就是使用另外的一个进程的该字段填入CR3中</li>
</ul>
</li>
<li>KernelTime/UserTime<ul>
<li>统计信息，记录一个进程在内核模式/用户模式下所花的时间</li>
</ul>
</li>
<li>Affinity<ul>
<li>规定进程里的所有线程能在哪个CPU上跑，如果值为1，那么只能在0号CPU上跑(00000001)；如果值为3，那么可以在0、1号CPU上跑（00000011）</li>
</ul>
</li>
<li>BasePriority<ul>
<li>基础优先级或最低优先级，该进程中的所有线程最起码的优先级</li>
</ul>
</li>
</ul>
<h3 id="EPROCESS其他成员"><a href="#EPROCESS其他成员" class="headerlink" title="EPROCESS其他成员"></a>EPROCESS其他成员</h3><ul>
<li>CreateTime/ExitTime<ul>
<li>进程的创建，退出时间</li>
</ul>
</li>
<li>UniqueProcessId<ul>
<li>PID</li>
</ul>
</li>
<li>ActiveProcessLinks<ul>
<li>双向链表，所有轰动滚成都连接在一起构成的一个链表，对其解链可以达到隐藏进程的目的。PsActiveProcessHead指向全局链表头</li>
</ul>
</li>
<li>QuetaUsage/QuotaPeak<ul>
<li>物理页相关的统计信息</li>
</ul>
</li>
<li>CommitCharge/PeakVirtualSize/VirtualSize<ul>
<li>虚拟内存相关的统计信息</li>
</ul>
</li>
<li>VadRoot<ul>
<li>平衡二叉树，标识0-2G用户空间哪些地址被分配，模块隐藏相关</li>
</ul>
</li>
<li>DebugPort/ExceptionPort<ul>
<li>调试相关，调试器和被调试程序的桥梁进行通信</li>
</ul>
</li>
<li>ObjectTable<ul>
<li>句柄表，反调试：查询其他进程的句柄表，若发现自身的EPROCESS则说明该进程正在对我调试</li>
</ul>
</li>
<li>ImageFileName<ul>
<li>进程镜像文件名，最多16字节</li>
</ul>
</li>
<li>ActiveThreads<ul>
<li>活动线程的数量</li>
</ul>
</li>
<li>PEB<ul>
<li>参考 潘爱民老师《windows内核原理与实现》第三章</li>
<li>BeingDebugged</li>
<li>LDR 进程模块信息，模块链表</li>
</ul>
</li>
</ul>
<h2 id="ETHREAD-线程结构体"><a href="#ETHREAD-线程结构体" class="headerlink" title="ETHREAD 线程结构体"></a>ETHREAD 线程结构体</h2><h3 id="KTHREAD"><a href="#KTHREAD" class="headerlink" title="KTHREAD"></a>KTHREAD</h3><ul>
<li>Header :_DISPATCHER_HEADER<ul>
<li>内核对象结构体带有此字段即为可等待对象，比如Mutex互斥体，Event事件等（WaitForSingleObject）</li>
</ul>
</li>
<li>InitialStack，StackLimit，KernelStack<ul>
<li>线程切换相关，将此字段赋值给TSS储存0环栈</li>
</ul>
</li>
<li>Teb<ul>
<li>Thread Environment Block 线程环境块，三环FS:[0] -&gt; TEB，在其中可以找到PEB</li>
</ul>
</li>
<li>DebugActive<ul>
<li>如果被调试就不是-1，如果是-1，则不能使用调试寄存器Dr0-Dr7</li>
</ul>
</li>
<li>ApcState,ApcQueueLock,ApcStatePointer,SavedApcState<ul>
<li>APC相关</li>
</ul>
</li>
<li>State<ul>
<li>线程状态：就绪、等待还是运行</li>
</ul>
</li>
<li>BasePriority<ul>
<li>初始值是所属进程的BasePriority的值(KPROCESS-&gt;BasePriority)，以后可以通过KeSetBasePriorityThread()函数重新设定</li>
</ul>
</li>
<li>WaitBlock<ul>
<li>等待哪个对象（WaitForSingleObject）</li>
</ul>
</li>
<li>ServiceTable<ul>
<li>指向系统服务表基址</li>
</ul>
</li>
<li>TrapFrame<ul>
<li>进0环时保存环境</li>
</ul>
</li>
<li>PreviousMode<ul>
<li>某些内核函数会判断程序是0环调用还是3环调用的</li>
</ul>
</li>
<li>ThreadListEntry<ul>
<li>双向链表，一个进程所有的线程都处在一个链表中，一共有两个这样的链表，EPROCESS中同样有</li>
</ul>
</li>
</ul>
<h3 id="ETHREAD其他成员"><a href="#ETHREAD其他成员" class="headerlink" title="ETHREAD其他成员"></a>ETHREAD其他成员</h3><ul>
<li>Cid<ul>
<li>当前线程的ID和当前进程PID，进程隐藏相关</li>
</ul>
</li>
<li>ThreadsProcess<ul>
<li>指向自己所属的进程EPROCESS，进程隐藏相关</li>
</ul>
</li>
<li>ThreadListEntry<ul>
<li>双向链表，一个进程所有的线程都处在一个链表中，一共有两个这样的链表，EPROCESS中同样有</li>
</ul>
</li>
</ul>
<h2 id="KPCR-CPU控制区（Processor-Control-Rregion）"><a href="#KPCR-CPU控制区（Processor-Control-Rregion）" class="headerlink" title="KPCR CPU控制区（Processor Control Rregion）"></a>KPCR CPU控制区（Processor Control Rregion）</h2><ul>
<li>当线程进入0环时，FS:[0]指向KPCR（3环时指向TEB）</li>
<li>每个CPU都有一个KPCR结构体（一个核心一个）</li>
<li>KPCR中储存了CPU本身要用的一些重要数据：GDT、IDT、以及线程相关的一些信息</li>
</ul>
<h3 id="NT-TIB主要成员"><a href="#NT-TIB主要成员" class="headerlink" title="_NT_TIB主要成员"></a>_NT_TIB主要成员</h3><ul>
<li>ExceptionList<ul>
<li>储存0环异常处理程序链表SEH，对比TEB中同样有这个结构储存3环异常处理程序链表SEH</li>
</ul>
</li>
<li>StackBase，StackLimit<ul>
<li>0环线程栈底和栈大小</li>
</ul>
</li>
<li>Self<ul>
<li>指向TIB自身</li>
</ul>
</li>
</ul>
<h3 id="KPCR其他成员"><a href="#KPCR其他成员" class="headerlink" title="KPCR其他成员"></a>KPCR其他成员</h3><ul>
<li>SelfPcr<ul>
<li>指向自己，方便寻址</li>
</ul>
</li>
<li>Prcb<ul>
<li>指向拓展结构体PRCB</li>
</ul>
</li>
<li>IDT<ul>
<li>IDT表基址</li>
</ul>
</li>
<li>GDT<ul>
<li>GDT表基址</li>
</ul>
</li>
<li>TSS<ul>
<li>指向TSS，每个CPU都有一个TSS</li>
</ul>
</li>
<li>Number<ul>
<li>CPU编号</li>
</ul>
</li>
<li>PrcbData：_KPRCB<ul>
<li>拓展结构体</li>
</ul>
</li>
</ul>
<h3 id="KPRCB"><a href="#KPRCB" class="headerlink" title="KPRCB"></a>KPRCB</h3><ul>
<li>CurrentThread<ul>
<li>当前CPU正在跑的线程</li>
</ul>
</li>
<li>NextThread<ul>
<li>下一个切换的线程</li>
</ul>
</li>
<li>IdleThread<ul>
<li>空闲线程，如果没有要跑的线程，就跑这个空闲线程</li>
</ul>
</li>
</ul>
<h2 id="等待链表、调度链表"><a href="#等待链表、调度链表" class="headerlink" title="等待链表、调度链表"></a>等待链表、调度链表</h2><p>在进程中对线程链表进行断链，OD等调试器查询不到该线程，但线程仍然在跑。说明两个问题，OD查询线程使用的API是通过线程链表去查询的；CPU在调度线程执行的时候不是使用这个链表。</p>
<p>线程有3仲状态：</p>
<ul>
<li>运行</li>
<li>就绪</li>
<li>阻塞</li>
</ul>
<h3 id="等待链表"><a href="#等待链表" class="headerlink" title="等待链表"></a>等待链表</h3><p>KiWaitListHead 双向链表指向KTHREAD.WaitListEntry，线程调用Sleep()或者WaitForSingleObject()等函数时，就插入这个链表</p>
<h3 id="33个链表"><a href="#33个链表" class="headerlink" title="33个链表"></a>33个链表</h3><p>处于运行状态的链表在KPCR中，就绪和等待全在另外33个链表中，1个等待链表，32个就绪链表</p>
<h3 id="调度（就绪）链表"><a href="#调度（就绪）链表" class="headerlink" title="调度（就绪）链表"></a>调度（就绪）链表</h3><p>KiDispatcherReadyListHead 存储32个双向链表的链表头，按优先级为下标排序</p>
<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><p>32位只有33个双向链表，多核也只有33个</p>
<p>64位有65个</p>
<p>服务器版本：KiWaitListHead只有一个，但KiDispatcherReadyListHead这个数组有几个CPU就有几组</p>
<h2 id="模拟线程切换"><a href="#模拟线程切换" class="headerlink" title="模拟线程切换"></a>模拟线程切换</h2><ul>
<li>线程不是被动切换而是主动切换</li>
<li>线程切换并没有使用TSS来保存寄存器，而是使用堆栈</li>
<li>线程切换的过程就是堆栈切换的过程</li>
</ul>
<h3 id="主动切换"><a href="#主动切换" class="headerlink" title="主动切换"></a>主动切换</h3><ul>
<li>windows中大多情况下通过调用SwapContext函数进行线程切换</li>
<li>线程切换时会比较是否属于同一进程，如果不是则切换cr3寄存器</li>
</ul>
<blockquote>
<p>如果不调用API，就可以一致占用CPU吗？</p>
</blockquote>
<h3 id="时钟中断切换"><a href="#时钟中断切换" class="headerlink" title="时钟中断切换"></a>时钟中断切换</h3><h3 id="时间片管理切换"><a href="#时间片管理切换" class="headerlink" title="时间片管理切换"></a>时间片管理切换</h3><h3 id="线程切换之TSS"><a href="#线程切换之TSS" class="headerlink" title="线程切换之TSS"></a>线程切换之TSS</h3><p>Intel设计TSS的目的是为了任务切换（线程切换），但Windows与Linux并没有使用，而是采用栈来保存线程的各种寄存器。</p>
<blockquote>
<p>一个CPU只有一个TSS（保存在KPCR中），但是线程很多，如何用一个TSS来保存所有线程的ESP0呢？</p>
</blockquote>
<p>切换线程时会将从TEB中取出目标线程的esp0 和 cr3 存到TSS中，其他不动</p>
<h3 id="线程切换之FS"><a href="#线程切换之FS" class="headerlink" title="线程切换之FS"></a>线程切换之FS</h3><p>系统中同时存在许多个线程，这就意味着fs在3环时指向的TEB要有多个（每个线程一个）</p>
<p>但在实际的使用中我们发现，当我们在3环查看不同线程的FS寄存器时，FS的段选择子都是相同的，那是如何实现通过一个FS寄存器指向多个TEB呢？</p>
<p>线程切换时会取出目标进程的TEB存入FS段描述符基址中</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>有三种情况会导致线程切换：</p>
<ul>
<li>当前线程主动调用API：KiSwapThread KiSwapContext</li>
<li>当前线程时间片稻妻：KiDispatchInterrupt KiQuantumEnd </li>
<li>有备用线程（KPCR.PrcbData.NextThread）：KiDispatchInterrupt </li>
</ul>
<p>在KiSwapThread与KiQuantumEnd 函数中都是通过KiFindReadyThread来找下一个要切换的线程，那么<code>KiFindReadyThread</code>时根据<code>什么条件</code>来选择下一个要执行的线程呢？</p>
<p>根据之前说到的KiDispatcherReadyListHead 数组中的双向链表的下标作为优先级进行调度</p>
<h3 id="进程挂靠"><a href="#进程挂靠" class="headerlink" title="进程挂靠"></a>进程挂靠</h3>
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"787cc455593c1fb9cfcd","clientSecret":"f6abba3d9cc77878426ee16aa8bcb980fd3cd70c","repo":"s1vona.github.io","owner":"s1vona","admin":["s1vona"],"distractionFreeMode":true};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Sivona</span>
                    </p>
                
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2020 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Enforce justice on behalf of Heaven.</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E6%BB%B4%E6%B0%B4%E9%80%86%E5%90%91/"># 滴水逆向</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/11/08/2020%E5%A4%AA%E6%B9%96%E6%9D%AFwp/">2020太湖杯wp</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Sivona | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
    <div>
        友情链接: 
       <div>
        <a class="theme-link"  href="https://sncker.github.io" target="_blank" rel="noopener"> SNCKER's blog </a><span>&nbsp;&nbsp;</span>
        <a class="theme-link"  href="https://www.cnblogs.com/lnjoy/" target="_blank" rel="noopener"> EnJoy_July 's blog' </a><span>&nbsp;&nbsp;</span>
       </div>
       
      </div>
</footer>

    </div>
</body>
</html>
